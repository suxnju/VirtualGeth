from .Transaction import Transaction

class Constant:
	MODULO = 2**256
	UPPER_UINT256 = 2**256 - 1

	msg_caller = Transaction.From
	msg_value = Transaction.Value
	msg_input = Transaction.Input
	
	timestamp = Transaction.Timestamp

OPCODE_TO_INSTR  = {
	"STOP":(0x00,"STOP()","halts execution of the contract"),
	"ADD":(0x01,"a+b","(u)int256 addition modulo 2**256"),
	"MUL":(0x02,"a*b","(u)int256 multiplication modulo 2**256"),
	"SUB":(0x03,"a-b","(u)int256 subtraction modulo 2**256"),
	"DIV":(0x04,"a//b","uint256 division"),
	"SDIV":(0x05,"a//b","int256 division"),
	"MOD":(0x06,"a%b","uint256 modulus"),
	"SMOD":(0x07,"a%b","int256 modulus"),
	"ADDMOD":(0x08,"(a+b)%N","(u)int256 addition modulo N"),
	"MULMOD":(0x09,"(a*b)%N","(u)int256 multiplication modulo N"),
	"EXP":(0x0A,"a**b","uint256 exponentiation modulo 2**256"),
	"SIGNEXTEND":(0x0B,"y=SIGNEXTEND(x,b)","sign extends x from (b + 1) * 8 bits to 256 bits."),
	"LT":(0x10,"a<b","uint256 comparison"),
	"GT":(0x11,"a>b","uint256 comparison"),
	"SLT":(0x12,"a<b","int256 comparison"),
	"SGT":(0x13,"a>b","int256 comparison"),
	"EQ":(0x14,"a==b","(u)int256 equality"),
	"ISZERO":(0x15,"a==0","(u)int256 is zero"),
	"AND":(0x16,"a&b","256-bit bitwise and"),
	"OR":(0x17,"a|b","256-bit bitwise or"),
	"XOR":(0x18,"a^b","256-bit bitwise xor"),
	"NOT":(0x19,"~a","256-bit bitwise not"),
	"BYTE":(0x1A,"y=(x>>(248-i*8))&0xFF","ith byte of (u)int256 x, counting from most significant byte"),
	"SHL":(0x1B,"value<<shift","256-bit shift left"),
	"SHR":(0x1C,"value>>shift","256-bit shift right"),
	"SAR":(0x1D,"value>>shift","int256 shift right"),
	"SHA3":(0x20,"hash=keccak256(memory[offset:offset+length])","keccak256"),
	"ADDRESS":(0x30,"address(this)","address of the executing contract"),
	"BALANCE":(0x31,"address(addr).balance","address balance in wei"),
	"ORIGIN":(0x32,"tx.origin","transaction origin address"),
	"CALLER":(0x33,"msg.caller","message caller address"),
	"CALLVALUE":(0x34,"msg.value","message funds in wei"),
	"CALLDATALOAD":(0x35,"msg.data[i:i+32]","reads a (u)int256 from message data"),
	"CALLDATASIZE":(0x36,"msg.data.size","message data length in bytes"),
	"CALLDATACOPY":(0x37,"memory[destOffset:destOffset+length]=msg.data[offset:offset+length]","copy message data"),
	"CODESIZE":(0x38,"address(this).code.size","length of the executing contract's code in bytes"),
	"CODECOPY":(0x39,"memory[destOffset:destOffset+length]=address(this).code[offset:offset+length]","copy executing contract's bytecode"),
	"GASPRICE":(0x3A,"tx.gasprice","gas price of the executing transaction, in wei per unit of gas"),
	"EXTCODESIZE":(0x3B,"address(addr).code.size","length of the contract bytecode at addr, in bytes"),
	"EXTCODECOPY":(0x3C,"memory[destOffset:destOffset+length]=address(addr).code[offset:offset+length]","copy contract's bytecode"),
	"RETURNDATASIZE":(0x3D,"size=RETURNDATASIZE()","the size of the returned data from the last external call, in bytes"),
	"RETURNDATACOPY":(0x3E,"memory[destOffset:destOffset+length]=RETURNDATA[offset:offset+length]","copy returned data"),
	"EXTCODEHASH":(0x3F,"hash=address(addr).exists?keccak256(address(addr).code):0","hash of the contract bytecode at addr, see EIP-1052"),
	"BLOCKHASH":(0x40,"hash=block.blockHash(blockNumber)","hash of the specific block, only valid for the 256 most recent blocks, excluding the current one"),
	"COINBASE":(0x41,"block.coinbase","address of the current block's miner"),
	"TIMESTAMP":(0x42,"block.timestamp","current block's Unix timestamp in seconds"),
	"NUMBER":(0x43,"block.number","current block's number"),
	"DIFFICULTY":(0x44,"block.difficulty","current block's difficulty"),
	"GASLIMIT":(0x45,"block.gaslimit","current block's gas limit"),
	"POP":(0x50,"POP()","pops a (u)int256 off the stack and discards it"),
	"MLOAD":(0x51,"value=memory[offset:offset+32]","reads a (u)int256 from memory"),
	"MSTORE":(0x52,"memory[offset:offset+32]=value","writes a (u)int256 to memory"),
	"MSTORE8":(0x53,"memory[offset]=value&0xFF","writes a uint8 to memory"),
	"SLOAD":(0x54,"value=storage[key]","reads a (u)int256 from storage"),
	"SSTORE":(0x55,"storage[key]=value","writes a (u)int256 to storage"),
	"JUMP":(0x56,"$pc=destination","unconditional jump"),
	"JUMPI":(0x57,"$pc=cond?destination:$pc+1","conditional jump if condition is truthy"),
	"PC":(0x58,"$pc","program counter"),
	"MSIZE":(0x59,"size=MSIZE()","size of memory for this contract execution, in bytes"),
	"GAS":(0x5A,"gasRemaining=GAS()","remaining gas"),
	"JUMPDEST":(0x5B,"","metadata to annotate possible jump destinations"),
	"PUSH1":(0x60,"PUSH(uint8)","pushes a 1-byte value onto the stack"),
	"PUSH2":(0x61,"PUSH(uint16)","pushes a 2-byte value onto the stack"),
	"PUSH3":(0x62,"PUSH(uint24)","pushes a 3-byte value onto the stack"),
	"PUSH4":(0x63,"PUSH(uint32)","pushes a 4-byte value onto the stack"),
	"PUSH5":(0x64,"PUSH(uint40)","pushes a 5-byte value onto the stack"),
	"PUSH6":(0x65,"PUSH(uint48)","pushes a 6-byte value onto the stack"),
	"PUSH7":(0x66,"PUSH(uint56)","pushes a 7-byte value onto the stack"),
	"PUSH8":(0x67,"PUSH(uint64)","pushes a 8-byte value onto the stack"),
	"PUSH9":(0x68,"PUSH(uint72)","pushes a 9-byte value onto the stack"),
	"PUSH10":(0x69,"PUSH(uint80)","pushes a 10-byte value onto the stack"),
	"PUSH11":(0x6A,"PUSH(uint88)","pushes a 11-byte value onto the stack"),
	"PUSH12":(0x6B,"PUSH(uint96)","pushes a 12-byte value onto the stack"),
	"PUSH13":(0x6C,"PUSH(uint104)","pushes a 13-byte value onto the stack"),
	"PUSH14":(0x6D,"PUSH(uint112)","pushes a 14-byte value onto the stack"),
	"PUSH15":(0x6E,"PUSH(uint120)","pushes a 15-byte value onto the stack"),
	"PUSH16":(0x6F,"PUSH(uint128)","pushes a 16-byte value onto the stack"),
	"PUSH17":(0x70,"PUSH(uint136)","pushes a 17-byte value onto the stack"),
	"PUSH18":(0x71,"PUSH(uint144)","pushes a 18-byte value onto the stack"),
	"PUSH19":(0x72,"PUSH(uint152)","pushes a 19-byte value onto the stack"),
	"PUSH20":(0x73,"PUSH(uint160)","pushes a 20-byte value onto the stack"),
	"PUSH21":(0x74,"PUSH(uint168)","pushes a 21-byte value onto the stack"),
	"PUSH22":(0x75,"PUSH(uint176)","pushes a 22-byte value onto the stack"),
	"PUSH23":(0x76,"PUSH(uint184)","pushes a 23-byte value onto the stack"),
	"PUSH24":(0x77,"PUSH(uint192)","pushes a 24-byte value onto the stack"),
	"PUSH25":(0x78,"PUSH(uint200)","pushes a 25-byte value onto the stack"),
	"PUSH26":(0x79,"PUSH(uint208)","pushes a 26-byte value onto the stack"),
	"PUSH27":(0x7A,"PUSH(uint216)","pushes a 27-byte value onto the stack"),
	"PUSH28":(0x7B,"PUSH(uint224)","pushes a 28-byte value onto the stack"),
	"PUSH29":(0x7C,"PUSH(uint232)","pushes a 29-byte value onto the stack"),
	"PUSH30":(0x7D,"PUSH(uint240)","pushes a 30-byte value onto the stack"),
	"PUSH31":(0x7E,"PUSH(uint248)","pushes a 31-byte value onto the stack"),
	"PUSH32":(0x7F,"PUSH(uint256)","pushes a 32-byte value onto the stack"),
	"DUP1":(0x80,"PUSH(value)","clones the last value on the stack"),
	"DUP2":(0x81,"PUSH(value)","clones the 2nd last value on the stack"),
	"DUP3":(0x82,"PUSH(value)","clones the 3rd last value on the stack"),
	"DUP4":(0x83,"PUSH(value)","clones the 4th last value on the stack"),
	"DUP5":(0x84,"PUSH(value)","clones the 5th last value on the stack"),
	"DUP6":(0x85,"PUSH(value)","clones the 6th last value on the stack"),
	"DUP7":(0x86,"PUSH(value)","clones the 7th last value on the stack"),
	"DUP8":(0x87,"PUSH(value)","clones the 8th last value on the stack"),
	"DUP9":(0x88,"PUSH(value)","clones the 9th last value on the stack"),
	"DUP10":(0x89,"PUSH(value)","clones the 10th last value on the stack"),
	"DUP11":(0x8A,"PUSH(value)","clones the 11th last value on the stack"),
	"DUP12":(0x8B,"PUSH(value)","clones the 12th last value on the stack"),
	"DUP13":(0x8C,"PUSH(value)","clones the 13th last value on the stack"),
	"DUP14":(0x8D,"PUSH(value)","clones the 14th last value on the stack"),
	"DUP15":(0x8E,"PUSH(value)","clones the 15th last value on the stack"),
	"DUP16":(0x8F,"PUSH(value)","clones the 16th last value on the stack"),
	"SWAP1":(0x90,"a,b=b,a","swaps the last two values on the stack"),
	"SWAP2":(0x91,"a,b=b,a","swaps the top of the stack with the 3rd last element"),
	"SWAP3":(0x92,"a,b=b,a","swaps the top of the stack with the 4th last element"),
	"SWAP4":(0x93,"a,b=b,a","swaps the top of the stack with the 5th last element"),
	"SWAP5":(0x94,"a,b=b,a","swaps the top of the stack with the 6th last element"),
	"SWAP6":(0x95,"a,b=b,a","swaps the top of the stack with the 7th last element"),
	"SWAP7":(0x96,"a,b=b,a","swaps the top of the stack with the 8th last element"),
	"SWAP8":(0x97,"a,b=b,a","swaps the top of the stack with the 9th last element"),
	"SWAP9":(0x98,"a,b=b,a","swaps the top of the stack with the 10th last element"),
	"SWAP10":(0x99,"a,b=b,a","swaps the top of the stack with the 11th last element"),
	"SWAP11":(0x9A,"a,b=b,a","swaps the top of the stack with the 12th last element"),
	"SWAP12":(0x9B,"a,b=b,a","swaps the top of the stack with the 13th last element"),
	"SWAP13":(0x9C,"a,b=b,a","swaps the top of the stack with the 14th last element"),
	"SWAP14":(0x9D,"a,b=b,a","swaps the top of the stack with the 15th last element"),
	"SWAP15":(0x9E,"a,b=b,a","swaps the top of the stack with the 16th last element"),
	"SWAP16":(0x9F,"a,b=b,a","swaps the top of the stack with the 17th last element"),
	"LOG0":(0xA0,"LOG0(memory[offset:offset+length])","fires an event"),
	"LOG1":(0xA1,"LOG1(memory[offset:offset+length],topic0)","fires an event"),
	"LOG2":(0xA2,"LOG2(memory[offset:offset+length],topic0,topic1)","fires an event"),
	"LOG3":(0xA3,"LOG3(memory[offset:offset+length],topic0,topic1,topic2)","fires an event"),
	"LOG4":(0xA4,"LOG4(memory[offset:offset+length],topic0,topic1,topic2,topic3)","fires an event"),
	"PUSH":(0xB0,"???","???"),
	"DUP":(0xB1,"???","???"),
	"SWAP":(0xB2,"???","???"),
	"CREATE":(0xF0,"addr=newmemory[offset:offset+length].value(value)","creates a child contract"),
	"CALL":(0xF1,"success,memory[retOffset:retOffset+retLength]=address(addr).call.gas(gas).value(value)(memory[argsOffset:argsOffset+argsLength])","calls a method in another contract"),
	"CALLCODE":(0xF2,"success,memory[retOffset:retOffset+retLength]=address(addr).callcode.gas(gas).value(value)(memory[argsOffset:argsOffset+argsLength])","???"),
	"RETURN":(0xF3,"returnmemory[offset:offset+length]","returns from this contract call"),
	"DELEGATECALL":(0xF4,"success,memory[retOffset:retOffset+retLength]=address(addr).delegatecall.gas(gas)(memory[argsOffset:argsOffset+argsLength])","calls a method in another contract, using the storage of the current contract"),
	"CREATE2":(0xF5,"addr=newmemory[offset:offset+length].value(value)","creates a child contract with a deterministic address, see EIP-1014"),
	"STATICCALL":(0xFA,"success,memory[retOffset:retOffset+retLength]=address(addr).staticcall.gas(gas)(memory[argsOffset:argsOffset+argsLength])","calls a method in another contract with state changes such as contract creation, event emission, storage modification and contract destruction disallowed, see EIP-214"),
	"REVERT":(0xFD,"revert(memory[offset:offset+length])","reverts with return data"),
	"SELFDESTRUCT":(0xFF,"selfdestruct(address(addr))","destroys the contract and sends all funds to addr.")
}